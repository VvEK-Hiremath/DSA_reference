# Algorithms Overview

This folder contains concise notes, explanations, and pseudocode for major algorithmic paradigms and techniques. Each document is designed for quick study, interview preparation, and reference.

## Contents

- **Backtracking**: Concepts, pruning strategies, and classic problems like permutations, N-Queens, Sudoku, and more. Includes generic templates and debugging tips.
- **Divide and Conquer**: Pattern, recurrence analysis, and examples such as Merge Sort, Quick Sort, Karatsuba Multiplication, and Closest Pair of Points.
- **Dynamic Programming**: Memoization vs tabulation, common patterns, and classic problems like Knapsack, LCS, LIS, Edit Distance, and Matrix Chain Multiplication.
- **Greedy Algorithms**: When greedy works, proof techniques, and examples like Activity Selection, Huffman Coding, Coin Change, and graph algorithms (Kruskal, Prim, Dijkstra).
- **Pattern Searching**: String search algorithms including Naive, Rabin–Karp, KMP, Z-algorithm, Boyer–Moore, and Aho–Corasick, with complexity and use-cases.
- **Searching Algorithms**: Linear, binary, ternary, jump, exponential, interpolation, and data-structure-based searches (BST, hash table, trie, graph searches).
- **Sorting Algorithms**: Comparison sorts (bubble, selection, insertion, shell), divide-and-conquer sorts (merge, quick, heap), and non-comparison sorts (counting, radix, bucket), with complexity and stability notes.

Each topic is covered in its own markdown file for focused learning. See the respective files for detailed explanations and pseudocode.
